---
title: "Class 13"
author: "Kristiana Wong A16281367"
format: pdf
---

##Background
The data for this hands-on session comes from a published RNA-seq experiment where airway smooth muscle cells were treated with dexamethasone, a synthetic glucocorticoid steroid with anti-inflammatory effects (Himes et al. 2014). They found a number of differentially expressed genes but focus much of the discussion on a gene called CRISPLD2.

This gene encodes a secreted protein known to be involved in lung development, and SNPs in this gene in previous GWAS studies are associated with inhaled corticosteroid resistance and bronchodilator response in asthma patients.

##Bioconductor setup
```{r}
library(BiocManager)
library(DESeq2)
```

##Import countData and colData
```{r}
counts <- read.csv("airway_scaledcounts.csv", row.names=1)
metadata <- read.csv("airway_metadata.csv")
```

Now, take a look at the head of each.
```{r}
head(counts)
```
```{r}
head(metadata)
```

Q1. How many genes are in this dataset? 
```{r}
nrow(counts)
```
38,694 genes

Q2. How many ‘control’ cell lines do we have? 
```{r}
#View(metadata)
```
4 control cell lines

##Toy differential gene expression
Lets perform some exploratory differential gene expression analysis.

We first need to find the sample ids for the labeled controls and then calculate the mean counts per gene across the samples.
```{r}
control <- metadata[metadata[,"dex"]=="control",]
control.counts <- counts[ ,control$id]
control.mean <- rowSums( control.counts )/4 
head(control.mean)
```
Q3. How would you make the above code in either approach more robust? Is there a function that could help here? 
rowMeans()

Q4. Follow the same procedure for the treated samples (i.e. calculate the mean per gene across drug treated samples and assign to a labeled vector called treated.mean)
```{r}
treated <- metadata[metadata[,"dex"]=="treated",]
treated.counts <- counts[ ,treated$id]
treated.mean <- rowSums(treated.counts)/4
head(treated.mean)
```
Now lets combine our meancount data
```{r}
meancounts <- data.frame(control.mean, treated.mean)
```


Q5 (a). Create a scatter plot showing the mean of the treated samples against the mean of the control samples.
```{r}
library(ggplot2)

ggplot(meancounts) +
  aes(x = meancounts[,1], y = meancounts [,2]) +
  geom_point() +
  labs(x = "log control counts", y = "log treated counts") +
  scale_x_continuous(trans="log2") +
  scale_y_continuous(trans="log2")
```

We often log2 data since if there is no change, the log2 value will be 0, if doubled it will be 1, and if halved it will be -1.

Here we calculate log2foldchange, add it to our meancounts data.frame and inspect the results either with the head() or the View() function for example.
```{r}
meancounts$log2fc <- log2(meancounts[,"treated.mean"]/meancounts[,"control.mean"])
head(meancounts)
```

There are a couple of “weird” results. Namely, the NaN (“not a number”) and -Inf (negative infinity) results. Let’s filter our data to remove these genes.
```{r}
zero.vals <- which(meancounts[,1:2]==0, arr.ind=TRUE)

to.rm <- unique(zero.vals[,1])
mycounts <- meancounts[-to.rm,]
head(mycounts)
```
Q7. What is the purpose of the arr.ind argument in the which() function call above? Why would we then take the first column of the output and need to call the unique() function?
The arr.ind=TRUE argument will tell which() to return both the row and column indices where there are TRUE values. In this case this will tell us which genes and samples have 0 counts. Calling unique() ensures we don’t count any row twice if it has zero entries in both samples.

Let’s filter the dataset both ways to see how many genes are up or down-regulated.
```{r}
up.ind <- mycounts$log2fc > 2
down.ind <- mycounts$log2fc < (-2)
```

```{r}
sum(up.ind)
sum(down.ind)
```

Q8. Using the up.ind vector above can you determine how many up regulated genes we have at the greater than 2 fc level? 
250

Q9. Using the down.ind vector above can you determine how many down regulated genes we have at the greater than 2 fc level? 
367

Q10. Do you trust these results? Why or why not?
No I don't trust these, since from the dataset of a few thousand only a couple hundred are returned. There might hits that are not actually recorded in this data being represented.

##Setting up for DESeq
```{r}
library(DESeq2)
citation("DESeq2")
```
We will use the DESeqDataSetFromMatrix() function to build the required DESeqDataSet object and call it dds, short for our DESeqDataSet. If you get a warning about “some variables in design formula are characters, converting to factors” don’t worry about it.
```{r}
dds <- DESeqDataSetFromMatrix(countData=counts, 
                              colData=metadata, 
                              design=~dex)
dds
```
##Principal Component Analysis (PCA)
Before running DESeq analysis we can look how the count data samples are related to one another via Principal Component Analysis (PCA). We must normalize the data via vst() transformation.
```{r}
vsd <- vst(dds, blind = FALSE)
plotPCA(vsd, intgroup = c("dex"))
```
We can also build the PCA plot from scratch using the ggplot2 package. This is done by asking the plotPCA function to return the data used for plotting rather than building the plot.
```{r}
pcaData <- plotPCA(vsd, intgroup=c("dex"), returnData=TRUE)

percentVar <- round(100 * attr(pcaData, "percentVar"))
ggplot(pcaData) +
  aes(x = PC1, y = PC2, color = dex) +
  geom_point(size =3) +
  xlab(paste0("PC1: ", percentVar[1], "% variance")) +
  ylab(paste0("PC2: ", percentVar[2], "% variance")) +
  coord_fixed() +
  theme_bw()
```
##DESeq analysis
Here, we’re running the DESeq pipeline on the dds object, and reassigning the whole thing back to dds, which will now be a DESeqDataSet populated with all those values.
```{r}
dds <- DESeq(dds)
```

We can get results out of the object simply by calling the results() function on the DESeqDataSet that has been run through the pipeline. 
```{r}
res <- results(dds)
res
```
Convert the res object to a data.frame with the as.data.frame() function and then pass it to View() to bring it up in a data viewer.
```{r}
res = as.data.frame(res)
```
```{r}
summary(res)
res05 <- results(dds, alpha=0.05)
summary(res05)
```

##Add Annotation data

We will use one of Bioconductor’s main annotation packages to help with mapping between various ID schemes. Here we load the AnnotationDbi package and the annotation data package for humans org.Hs.eg.db.
```{r}
library("AnnotationDbi")
library("org.Hs.eg.db")
```

We can use the mapIds() function to add individual columns to our results table. We provide the row names of our results table as a key, and specify that keytype=ENSEMBL. The column argument tells the mapIds() function which information we want, and the multiVals argument tells the function what to do if there are multiple possible values for a single input value. 
```{r}
res$symbol <- mapIds(org.Hs.eg.db,
                     keys=row.names(res), # Our genenames
                     keytype="ENSEMBL",        # The format of our genenames
                     column="SYMBOL",          # The new format we want to add
                     multiVals="first")
```
Q11. Run the mapIds() function two more times to add the Entrez ID and UniProt accession and GENENAME as new columns called res$entrez, res$uniprot and res$genename.
```{r}
res$entrez <- mapIds(org.Hs.eg.db,
                     keys=row.names(res), # Our genenames
                     keytype="ENSEMBL",        # The format of our genenames
                     column="ENTREZID",          # The new format we want to add
                     multiVals="first")

res$uniprot <- mapIds(org.Hs.eg.db,
                     keys=row.names(res), # Our genenames
                     keytype="ENSEMBL",        # The format of our genenames
                     column="UNIPROT",          # The new format we want to add
                     multiVals="first")

res$genename <- mapIds(org.Hs.eg.db,
                     keys=row.names(res), # Our genenames
                     keytype="ENSEMBL",        # The format of our genenames
                     column="GENENAME",          # The new format we want to add
                     multiVals="first")
head(res)
```
Now view by adjusted p-value
```{r}
ord <- order( res$padj )
#View(res[ord,])
head(res[ord,])
```
And write a csv file with the ordered results
```{r}
write.csv(res[ord,], "deseq_results.csv")
```

##Data Visualization
Let’s make a commonly produced visualization from this data, namely a so-called Volcano plot. These summary figures are frequently used to highlight the proportion of genes that are both significantly regulated and display a high fold change.
```{r}
plot( res$log2FoldChange,  -log(res$padj), 
 ylab="-Log(P-value)", xlab="Log2(FoldChange)")

# Add some cut-off lines
abline(v=c(-2,2), col="darkgray", lty=2)
abline(h=-log(0.05), col="darkgray", lty=2)

# Setup our custom point color vector 
mycols <- rep("gray", nrow(res))
mycols[ abs(res$log2FoldChange) > 2 ]  <- "red" 

inds <- (res$padj < 0.01) & (abs(res$log2FoldChange) > 2 )
mycols[ inds ] <- "blue"

# Volcano plot with custom colors 
plot( res$log2FoldChange,  -log(res$padj), 
 col=mycols, ylab="-Log(P-value)", xlab="Log2(FoldChange)" )

# Cut-off lines
abline(v=c(-2,2), col="gray", lty=2)
abline(h=-log(0.1), col="gray", lty=2)
```

For an enhanced volcano plot, use the EnhanchedVolcano package from bioconductor.
```{r}
library(EnhancedVolcano)

x <- as.data.frame(res)

EnhancedVolcano(x,
    lab = x$symbol,
    x = 'log2FoldChange',
    y = 'pvalue')
```
##Pathway Analysis
Now that I have my annotations I can talk to different databases that use these IDs.

We will use the gage package to do geneset analysis (aka pathway analysis, geneset enrichment, overlap analysis). We will use KEGG first. 
```{r}
library(pathview)
library(gage)
library(gageData)

data(kegg.sets.hs)

# Examine the first 2 pathways in this kegg set for humans
head(kegg.sets.hs, 2)
```
Foldchanges is the main gage function that requires a named vector of fold changes where the name of the values are the entrez gene IDs
```{r}
foldchanges = res$log2FoldChange
names(foldchanges) = res$entrez
head(foldchanges)
```

Now, let’s run the gage pathway analysis.
```{r}
# Get the results
keggres = gage(foldchanges, gsets=kegg.sets.hs)
```

```{r}
attributes(keggres)
```

```{r}
head(keggres$less, 3)
```
I can now use the returned pathway IDs from KEGG as input to the 'pathview' package to make pathway figures with our DEGs highlighted
```{r}
pathview(gene.data=foldchanges, pathway.id="hsa05310")
```
![ ](hsa05310.pathview.png)
```{r}
# A different PDF based output of the same data
pathview(gene.data=foldchanges, pathway.id="hsa05310", kegg.native=FALSE)
```